from google.appengine.api import memcache
import logging
import cachepy
from app import App

# layer_cache provides an easy way to cache the result of functions in
# both memcache and cachepy's storage for quick retrieval later.
#
#
#
# _____Explanation by examples:_____
#
# Cache in both memcache and cachepy the result of
# this long-running function using a static key,
# and return the result when available instead of recalculating:
#
# import layer_cache
#
# @layer_cache.cache()
# def calculate_user_averages():
#    ...do lots of long-running work...
#    return result_for_cache
#
#
# and with expiration every minute:
#
# @layer_cache.cache(expiration=60)
# def calculate_user_averages():
#    ...do lots of long-running work...
#    return result_for_cache
#
#
# Cache using key generated by utility function that
# varies the key based on the function's input parameters:
#
# @layer_cache.cache_with_key_fxn(lambda object: "layer_cache_key_for_object_%s" % object.id())
# def calculate_object_average(object):
#   ... do lots of long-running work...
#   return result_for_cache
#
#
# _____Manually busting the cache:_____
#
# When you call your cached function, just pass a special "bust_cache"
# named parameter to ignore any existing cached values and replace
# with whatever is newly returned:
#
# calculate_object_average(object, bust_cache=True)
#
#
#
# _____Other settings/options:_____
#
# Only cache in memcache, not cachepy's in-app memory cache:
# @layer_cache.cache(... layer=SINGLE_LAYER_MEMCACHE_ONLY)
#
# Only cache in cachepy's in-app memory cache, not memcache:
# @layer_cache.cache(... layer=SINGLE_LAYER_IN_APP_MEMORY_CACHE_ONLY)
#
# Persist the cached values across different uploaded app verions
# (by default this will not happen w/ memcache):
# @layer_cache.cache(... persist_across_app_versions=True)

DEFAULT_LAYER_CACHE_EXPIRATION_SECONDS = 60 * 60 * 24 * 10 # Expire after 10 days by default
DUAL_LAYER_MEMCACHE_AND_IN_APP_MEMORY_CACHE = 0 # Cache in both memcache and cachepy by default
SINGLE_LAYER_MEMCACHE_ONLY = 1
SINGLE_LAYER_IN_APP_MEMORY_CACHE_ONLY = 2

def cache(
        expiration=DEFAULT_LAYER_CACHE_EXPIRATION_SECONDS,
        layer = DUAL_LAYER_MEMCACHE_AND_IN_APP_MEMORY_CACHE,
        persist_across_app_versions = False):
    def decorator(target):
        key = "__layer_cache_%s.%s__" % (target.__module__, target.__name__)
        def wrapper(*args, **kwargs):
            return layer_cache_check_set_return(target, lambda: key, expiration, layer, persist_across_app_versions, *args, **kwargs)
        return wrapper
    return decorator

def cache_with_key_fxn(
        key_fxn, 
        expiration=DEFAULT_LAYER_CACHE_EXPIRATION_SECONDS,
        layer = DUAL_LAYER_MEMCACHE_AND_IN_APP_MEMORY_CACHE,
        persist_across_app_versions = False):
    def decorator(target):
        def wrapper(*args, **kwargs):
            return layer_cache_check_set_return(target, key_fxn, expiration, layer, persist_across_app_versions, *args, **kwargs)
        return wrapper
    return decorator

def layer_cache_check_set_return(
        target, 
        key_fxn, 
        expiration = DEFAULT_LAYER_CACHE_EXPIRATION_SECONDS, 
        layer = DUAL_LAYER_MEMCACHE_AND_IN_APP_MEMORY_CACHE,
        persist_across_app_versions = False,
        *args, 
        **kwargs):

    key = key_fxn(*args, **kwargs)
    namespace = App.version

    if persist_across_app_versions:
        namespace = None
    bust_cache = kwargs.get("bust_cache", False)

    if not bust_cache:
        if layer != SINGLE_LAYER_MEMCACHE_ONLY:
            result = cachepy.get(key)
            if result is not None:
                return result

        if layer != SINGLE_LAYER_IN_APP_MEMORY_CACHE_ONLY:
            result = memcache.get(key, namespace=namespace)
            if result is not None:
                cachepy.set(key, result)
                return result

    result = target(*args, **kwargs)

    # In case the key's value has been changed by target's execution
    key = key_fxn(*args, **kwargs)

    if layer != SINGLE_LAYER_MEMCACHE_ONLY:
        cachepy.set(key, result, expiry=expiration)

    if layer != SINGLE_LAYER_IN_APP_MEMORY_CACHE_ONLY:
        if not memcache.set(key, result, time=expiration, namespace=namespace):
            logging.error("Memcache set failed for %s" % key)

    return result

